import { validateMintConfig } from '@mintlify/validation';
import { promises as _promises } from 'fs';
import fse from 'fs-extra';
import { getConfigPath } from '../../utils.js';
const { readFile } = _promises;
export async function updateConfigFile(contentDirectoryPath) {
    const configTargetPath = 'src/_props/mint.json';
    const configPath = await getConfigPath(contentDirectoryPath);
    if (configPath == null) {
        throw Error('Must be run in a directory where a mint.json file exists.');
    }
    let configContents;
    try {
        configContents = await readFile(configPath, 'utf-8');
    }
    catch (err) {
        throw Error(`Unable to read mint.json: ${err}`);
    }
    let config;
    let validationResults;
    try {
        config = JSON.parse(configContents);
        validationResults = validateMintConfig(config);
    }
    catch (err) {
        throw Error(`Unable to parse mint.json: ${err}`);
    }
    if (validationResults.status === 'error') {
        throw Error(`Invalid mint.json:
${prettyStringForStringArr(validationResults.warnings, 'Warnings:')}
${prettyStringForStringArr(validationResults.errors, 'Errors:')}`);
    }
    try {
        await fse.copy(configPath, configTargetPath, { overwrite: true });
    }
    catch (err) {
        throw Error(`Unable to copy mint.json: ${err}`);
    }
    return config;
}
function prettyStringForStringArr(arr, startingStr) {
    if (arr.length === 0) {
        return '';
    }
    let formattedString = startingStr != undefined ? `${startingStr}\n` : '';
    arr.forEach((string) => {
        formattedString += `- ${string}\n`;
    });
    return formattedString;
}
