var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { SORT_DIRECTION } from '@mintlify/models';
import { any } from '../any.js';
import { comparer, getSetter, isArray, set } from '../sort.js';
import { isSortable } from './isSortable.js';
/**
 * Provides functionality to sort a given object based on provided sort options.
 *
 * @template T - The type of the object to be sorted.
 */
export class Sortable {
    constructor(obj, options = { direction: SORT_DIRECTION.ASCENDING }) {
        this.obj = obj;
        this.options = options;
        if (typeof obj !== 'object' || !(obj instanceof Object))
            return;
        if (typeof obj === 'string' || obj instanceof String)
            return;
        this.obj = obj;
        this.options = options;
        if (obj instanceof Sortable) {
            this.obj = obj.obj;
            this.options = Object.assign(Object.assign({}, obj.options), options);
        }
        if (isSortable(this.obj)) {
            const _a = this.obj, { options: opts } = _a, o = __rest(_a, ["options"]);
            this.obj = o;
            this.options = Object.assign(Object.assign({}, opts), this.options);
        }
    }
    sort(out) {
        const { order, direction } = this.options;
        out = out !== null && out !== void 0 ? out : this.obj;
        if (isArray(this.obj)) {
            const length = this.obj.length;
            const values = [...this.obj];
            this.obj.splice(0, this.obj.length);
            for (let i = 0; i < length; i++) {
                set(i, values[i], out, this.options.direction);
            }
        }
        else if (any(order)) {
            const entries = order.sort(comparer(direction, 'index'));
            const keys = entries.map((x) => x.key);
            const values = Object.fromEntries(new Map(keys.map((x) => [x, this.obj[x]])));
            entries.forEach((x) => out === null || out === void 0 ? true : delete out[x.key]);
            for (const entry of entries) {
                const set = getSetter(values, out);
                set(entry.key);
            }
        }
        else {
            const keys = Object.keys(this.obj).sort(comparer(direction));
            const values = Object.fromEntries(new Map(keys.map((x) => [x, this.obj[x]])));
            keys.forEach((x) => out === null || out === void 0 ? true : delete out[x]);
            for (const key of keys) {
                const set = getSetter(values, out);
                set(key);
            }
        }
        return out;
    }
    /**
     * Creates a new sortable entity for a given object with optional sortable properties.
     *
     * @param obj - The object that is to be converted into a sortable.
     *
     * @returns A new sortable instance.
     */
    static createSortable(obj) {
        var _a, _b, _c;
        const direction = (_b = (_a = obj.options) === null || _a === void 0 ? void 0 : _a.direction) !== null && _b !== void 0 ? _b : SORT_DIRECTION.ASCENDING;
        let order = (_c = obj.options) === null || _c === void 0 ? void 0 : _c.order;
        order = order !== null && order !== void 0 ? order : Object.keys(obj).map((key, index) => ({ key: key, index }));
        const options = {
            direction,
            order,
        };
        if (typeof obj !== 'string') {
            obj.options = options;
        }
        return new Sortable(obj, options);
    }
    /**
     * Creates a sortable entity from a given object and recursively does the same for its nested properties.
     *
     * @param obj - The root object to start from.
     *
     * @returns A new root sortable instance.
     */
    static createSortableRecursive(obj) {
        const isObject = typeof obj === 'object';
        if (isArray(obj)) {
            for (let i = 0; i < obj.length; i++) {
                this.createSortableRecursive(obj[i]);
            }
        }
        else if (isObject) {
            const keys = Object.keys(obj);
            for (const key of keys) {
                const value = obj[key];
                this.createSortableRecursive(value);
            }
        }
        return this.createSortable(obj);
    }
}
